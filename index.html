<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Mesh Background</title>
    <!-- Ladda Tailwind CSS för enkel och snabb styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Importera Inter-fonten för en modern look */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Förhindra scrollbars orsakade av canvas */
        }
        
        #mesh-canvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 10; /* Håll bakgrunden under innehållet */
            display: block;
        }

        #content-overlay {
            position: relative;
            z-index: 20; /* Innehållet måste ligga ovanpå canvasen */
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        /* En subtle glow effekt på kortet */
        .card-glow {
            box-shadow: 0 4px 15px rgba(10, 242, 255, 0.2), 0 0 50px rgba(45, 120, 255, 0.1);
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100">

    <!-- 1. Canvas-elementet för den animerade meshen -->
    <canvas id="mesh-canvas"></canvas>

    <!-- 2. Innehålls-overlay som ligger ovanpå meshen -->
    <div id="content-overlay">
        <div class="bg-gray-800/70 backdrop-blur-sm p-8 md:p-12 rounded-xl max-w-lg w-full text-center border border-gray-700 card-glow">
            <h1 class="text-4xl font-extrabold text-white mb-4">
                SpawnEngine HUD
            </h1>
            <p class="text-indigo-400 mb-6">
                Bakgrundssystem online. Redo för dataöverföring.
            </p>
            
            <div class="space-y-4">
                <div class="p-4 bg-gray-700/50 rounded-lg flex justify-between items-center">
                    <span class="text-gray-300 font-medium">Status:</span>
                    <span class="text-green-400 font-bold">OPTIMAL</span>
                </div>
                <div class="p-4 bg-gray-700/50 rounded-lg flex justify-between items-center">
                    <span class="text-gray-300 font-medium">Latens:</span>
                    <span class="text-yellow-400 font-bold">24 ms</span>
                </div>
            </div>

            <button class="mt-8 w-full py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold rounded-lg transition duration-200">
                Starta Sekvens
            </button>
        </div>
    </div>

    <!-- 3. Integrerad JavaScript från mesh-bg.js -->
    <script>
        // Mesh-bakgrundslogik (mesh-bg.js) - anpassad för att köras direkt.
        (function () {
            // Hämta canvasen.
            const canvas = document.getElementById("mesh-canvas");
            if (!canvas) {
                console.error("Canvas element with ID 'mesh-canvas' not found.");
                return;
            }

            const ctx = canvas.getContext("2d");
            let width = 0;
            let height = 0;
            let points = [];
            // Fler punkter för tätare och snyggare mesh på stora skärmar
            const POINT_ROWS = 12;
            const POINT_COLS = 18;

            function resize() {
                // Hantera Device Pixel Ratio för skarpare rendering på HiDPI-skärmar
                const dpr = window.devicePixelRatio || 1;
                width = window.innerWidth;
                height = window.innerHeight;

                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = width + "px";
                canvas.style.height = height + "px";
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

                initPoints();
            }

            function initPoints() {
                points = [];
                const xStep = width / (POINT_COLS - 1);
                const yStep = height / (POINT_ROWS - 1);

                for (let y = 0; y < POINT_ROWS; y++) {
                    for (let x = 0; x < POINT_COLS; x++) {
                        const px = x * xStep;
                        const py = y * yStep;
                        points.push({
                            x: px,
                            y: py,
                            baseX: px,
                            baseY: py,
                            // Ökat offset för lite mer dynamik
                            offsetX: (Math.random() - 0.5) * 25, 
                            offsetY: (Math.random() - 0.5) * 25,
                            speed: 0.3 + Math.random() * 0.3, // Lite långsammare hastighet
                            phase: Math.random() * Math.PI * 2,
                        });
                    }
                }
            }

            function update() {
                const t = performance.now() / 2000; // Använda en större nämnare för långsammare animation

                for (const p of points) {
                    const wobble = Math.sin(t * p.speed + p.phase);
                    const wobble2 = Math.cos(t * (p.speed * 0.7) + p.phase * 1.3);

                    p.x = p.baseX + p.offsetX * wobble;
                    p.y = p.baseY + p.offsetY * wobble2;
                }
            }

            function draw() {
                // Sätt bakgrunden till transparent (eller svart om man vill ha mörkare effekt)
                ctx.clearRect(0, 0, width, height);

                // bakgrundsglow - centrerad neonblå glöd
                const grad = ctx.createRadialGradient(
                    width * 0.5,
                    height * 0.5,
                    0,
                    width * 0.5,
                    height * 0.5,
                    Math.max(width, height) * 0.7
                );
                grad.addColorStop(0, "rgba(45, 120, 255, 0.1)");
                grad.addColorStop(0.3, "rgba(10, 242, 255, 0.05)");
                grad.addColorStop(1, "rgba(2, 3, 12, 0.0)");
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, width, height);

                ctx.lineWidth = 0.8; // Tunnare linjer
                ctx.strokeStyle = "rgba(120, 210, 255, 0.15)"; // Ljusare, mindre synliga linjer
                ctx.beginPath();

                // rita horisontella linjer (mesh)
                for (let row = 0; row < POINT_ROWS; row++) {
                    ctx.moveTo(points[row * POINT_COLS].x, points[row * POINT_COLS].y);
                    for (let col = 1; col < POINT_COLS; col++) {
                        const idx = row * POINT_COLS + col;
                        ctx.lineTo(points[idx].x, points[idx].y);
                    }
                }

                // rita vertikala linjer (mesh)
                for (let col = 0; col < POINT_COLS; col++) {
                    ctx.moveTo(points[col].x, points[col].y);
                    for (let row = 1; row < POINT_ROWS; row++) {
                        const idx = row * POINT_COLS + col;
                        ctx.lineTo(points[idx].x, points[idx].y);
                    }
                }

                ctx.stroke();

                // små noder/punkter
                ctx.fillStyle = "rgba(160, 240, 255, 0.7)";
                for (const p of points) {
                    // Blinkande/pulserande effekt
                    const pulse = 0.5 + Math.abs(Math.sin(performance.now() / 500 + p.phase)) * 0.5;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 1.2 * pulse, 0, Math.PI * 2); 
                    ctx.fill();
                }
            }

            function loop() {
                update();
                draw();
                requestAnimationFrame(loop);
            }

            // Starta allt
            window.addEventListener("resize", resize);
            resize();
            requestAnimationFrame(loop);
        })();
    </script>
</body>
</html>
